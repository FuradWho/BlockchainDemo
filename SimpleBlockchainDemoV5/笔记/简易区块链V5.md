# 简易区块链V5

## 上一个版本存在的问题

1. 地址没有使用字符串进行代替
2. 没有进行校验

## 解决步骤

- 创建密钥对
- 使用地址进行改写
- 交易签名

## 创建钱包文件存储地址

1. 创建一个结构WalletKeyPair秘钥对， 保存公钥和私钥
2. 给这个结构提供一个 方法Getaddress:私钥->公钥->地址

wallet.go文件之下进行添加：

```go
//1. 创建一个结构WalletKeyPair秘钥对，保存公钥和私钥
//2. 给这个结构提供一个方法GetAddress：私钥->公钥->地址

type WalletKeyPair struct {
	PrivateKey *ecdsa.PrivateKey

	//将公钥的X，Y进行字节流拼接后传输，这样在对端再进行切割还原，好处是可以方便后面的编码
	PublicKey []byte
}

```

对于钱包，公钥，私钥的创建：

```go
func NewWalletKeyPair() *WalletKeyPair {
    
	privateKey, err := ecdsa.GenerateKey(elliptic.P256(), rand.Reader)
	if err != nil {
		log.Panic(err)
	}
	publicKeyRaw := privateKey.PublicKey
	publicKey := append(publicKeyRaw.X.Bytes(), publicKeyRaw.Y.Bytes()...)
	return &WalletKeyPair{PrivateKey: privateKey, PublicKey: publicKey}
}
```

## 创建钱包地址

大致思路：

![image-20210902144225617](C:\Users\13375\OneDrive\桌面\实习文档\BlockchainDemo\SimpleBlockchainDemoV5\笔记\image-20210902144225617.png)

实现：

添加依赖：

```
go get golang.org/x/crypto/ripemd160
```

计算 20byte 的public hash key

```go
func HashPubKey(pubKey []byte) []byte {
	hash := sha256.Sum256(pubKey)
	//创建一个hash160对象
	//向hash160中write数据
	//做哈希运算
	rip160Haher := ripemd160.New()
	_, err := rip160Haher.Write(hash[:])
	if err != nil {
		log.Panic(err)
	}
	//Sum函数 Sum参数append到一起返回，传入nil
	publicHash := rip160Haher.Sum(nil)
	return publicHash
}
```

根据上述 21byte 进行hash转为 4byte 检验码

```go
func CheckSum(payload []byte) []byte {
	first := sha256.Sum256(payload)
	second := sha256.Sum256(first[:])
	//4字节校验码
	checksum := second[0:4]
	return checksum
}
```

实现：

```go
func (w *WalletKeyPair) GetAddress() string {

	publicHash := HashPubKey(w.PublicKey)
	version := 0x00
	//21字节的数据
	payload := append([]byte{byte(version)}, publicHash...)
	checksum := CheckSum(payload)
	//25字节
	payload = append(payload, checksum...)
	address := base58.Encode(payload)
	return address
}
```

测试：

```
$ SimpleBlockchainDemoV5 createWallet

创建钱包命令被调用
钱包文件不存在，准备创建!
新的钱包地址为: 1FXhypuwFUJM8sfv426GxVVrUnwaz1HtSG

```

## 对于钱包进行持久化保护

实现wallets.go

- 使用map把地址和密钥进行保存
- 持久化保存对于map进行保存

实现：

```go
package main

import (
	"bytes"
	"crypto/elliptic"
	"encoding/gob"
	"fmt"
	"io/ioutil"
)

type Wallets struct {
	WalletsMap map[string]*WalletKeyPair
}

//创建Wallets, 返回Wallets的实例
func NewWallets() *Wallets {
	var ws Wallets
	ws.WalletsMap = make(map[string]*WalletKeyPair)
	//1. 把所有的钱包从本地加载出来
	if !ws.LoadFromFile() {
		fmt.Printf("加载钱包数据失败!\n")
	}
	//2. 把实例返回
	return &ws
}
```

```go

//Wallets调用WalletKeypPair
func (ws *Wallets) CreateWallet() string {
   //滴啊用NewWalletKeyPair
   wallet := NewWalletKeyPair()
   //将返回的walletKeypair添加到WalletMap中
   address := wallet.GetAddress()
   ws.WalletsMap[address] = wallet
   //保存到本地文件
   res := ws.SaveToFile()
   if !res {
      fmt.Printf("创建钱包失败!\n")
      return ""
   }
   return address
}
```

## 本地保存

wallets.go 文件之下对于钱包进行保存

```go
//保存钱包到文件
func (ws *Wallets) SaveToFile() bool {
   var buffer bytes.Buffer
   gob.Register(elliptic.P256())
   encoder := gob.NewEncoder(&buffer)
   err := encoder.Encode(ws)
   if err != nil {
      fmt.Printf("钱包序列化失败!, err: %v\n", err)
      return false
   }
   content := buffer.Bytes()
   err = ioutil.WriteFile(WalletName, content, 0600)
   if err != nil {
      fmt.Printf("钱包创建失败!\n")
      return false
   }
   return true
}
```

## 钱包迭代加载

wallets.go 文件之下对于钱包进行迭代加载

```go
func (ws *Wallets) LoadFromFile() bool {
   //判断文件是否存在
   if !IsFileExist(WalletName) {
      fmt.Printf("钱包文件不存在，准备创建!\n")
      return true
   }
   //读取文件
   content, err := ioutil.ReadFile(WalletName)
   if err != nil {
      return false
   }
   gob.Register(elliptic.P256())
   decoder := gob.NewDecoder(bytes.NewReader(content))
   var wallets Wallets
   err = decoder.Decode(&wallets)
   if err != nil {
      fmt.Printf("err : %v\n", err)
      return false
   }
   ws.WalletsMap = wallets.WalletsMap
   return true
}
```

## 获取所有地址

wallets.go 文件之下对于钱包获取所有钱包地址，进行查看

```go
func (ws *Wallets) ListAddress() []string {
   //遍历ws.WalletsMap结构返回key即可
   var addresses []string
   for address, _ := range ws.WalletsMap {
      addresses = append(addresses, address)
   }
   return addresses
}
```

## 使用地址，密钥进行改写

transaction.go 文件对于交易结构进行改写：

```go
type TXInput struct {
   TXID []byte //交易id
   Index int64 //output的索引
   Signature []byte //交易签名
   PubKey []byte //公钥本身，不是公钥哈希
}

type TXOutput struct {
   Value float64 //转账金额
   PubKeyHash []byte //是公钥的哈希，不是公钥本身
    
}
```

我们转账的时候使用的是地址，根据hash推导出地址

## 实现NewTXOutput

给定转账地址，得到这个地址的公钥哈希，完成对output的锁定

```go

func (output *TXOutput) Lock(address string) {
   //address -> public key hash
   decodeInfo := base58.Decode(address)
   pubKeyHash := decodeInfo[1:len(decodeInfo)-4]
   output.PubKeyHash = pubKeyHash
    
}
```

```go
func NewTXOutput(value float64, address string) TXOutput {
    
   output := TXOutput{Value: value}
   output.Lock(address)
   return output
    
}
```

## 改写NewCoinbaseTx

```go
//实现挖矿挖矿交易，
//特点：只有输出，没有有效的输入(不需要引用id，不需要索引，不需要签名)
//把挖矿的人传递进来，因为有奖励
func NewCoinbaseTx(miner string, data string) *Transaction {

   //我们在后面的程序中，需要识别一个交易是否为coinbase，所以我们需要设置一些特殊的值，用于判断
   inputs := []TXInput{TXInput{nil, -1, nil, []byte(data)}}
   output := NewTXOutput(reward, miner)
   outputs := []TXOutput{output}
   tx := Transaction{nil, inputs, outputs}
   tx.SetTXID()
   return &tx
    
}
```

## 改写NewTransaction

实现思路：

1. 打开钱包，获取秘钥对
2. 获取公钥，私钥
3. 遍历账本，找到属于付款人的合适的金额，把这个outputs找到

```go
func NewTransaction(from, to string, amount float64, bc *BlockChain) *Transaction {
   //1. 打开钱包
   ws := NewWallets()
   //获取秘钥对
   wallet := ws.WalletsMap[from]

   if wallet == nil {
      fmt.Printf("%s 的私钥不存在，交易创建失败!\n", from)
      return nil
   }
   //2. 获取公钥，私钥
   //privateKey := wallet.PrivateKey //目前使用不到，步骤三签名时使用
   publickKey := wallet.PublicKey
   pubKeyHash := HashPubKey(wallet.PublicKey)
   utxos := make(map[string][]int64) //标识能用的utxo
   var resValue float64              //这些utxo存储的金额
   //1. 遍历账本，找到属于付款人的合适的金额，把这个outputs找到
   utxos, resValue = bc.FindNeedUtxos(pubKeyHash, amount)
   //2. 如果找到钱不足以转账，创建交易失败。
   if resValue < amount {
      fmt.Printf("余额不足，交易失败!\n")
      return nil
   }

   var inputs []TXInput
   var outputs []TXOutput

   //3. 将outputs转成inputs
   for txid , indexes := range utxos {
      for _, i := range indexes {
         input := TXInput{[]byte(txid), i, nil, publickKey}
         inputs = append(inputs, input)
      }
   }

   //4. 创建输出，创建一个属于收款人的output
   output := NewTXOutput(amount, to)
   outputs = append(outputs, output)

   //5. 如果有找零，创建属于付款人output
   if resValue > amount {
      output1 := NewTXOutput(resValue-amount, from)
      outputs = append(outputs, output1)
   }
   //创建交易
   tx := Transaction{nil, inputs, outputs}
   //6. 设置交易id
   tx.SetTXID()
   //7. 返回交易结构
   return &tx
}
```

## 使用HashPubKey改写GetAddress

wallet.go 文件之下：

```go
func HashPubKey(pubKey []byte) []byte {
   hash := sha256.Sum256(pubKey)
   rip160Haher := ripemd160.New()
   _, err := rip160Haher.Write(hash[:])

   if err != nil {
      log.Panic(err)
   }
   //Sum函数 Sum参数append到一起返回，传入nil
   publicHash := rip160Haher.Sum(nil)
   return publicHash
}
```

```go
func (w *WalletKeyPair) GetAddress() string {

   publicHash := HashPubKey(w.PublicKey)
   version := 0x00
   //21字节的数据
   payload := append([]byte{byte(version)}, publicHash...)
   checksum := CheckSum(payload)
   //25字节
   payload = append(payload, checksum...)
   address := base58.Encode(payload)
   return address
}
```

