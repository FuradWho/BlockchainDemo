# 简易区块链V5

## 上一个版本存在的问题

1. 地址没有使用字符串进行代替
2. 没有进行校验

## 解决步骤

- 创建密钥对
- 使用地址进行改写
- 交易签名

## 创建钱包文件存储地址

1. 创建一个结构WalletKeyPair秘钥对， 保存公钥和私钥
2. 给这个结构提供一个 方法Getaddress:私钥->公钥->地址

wallet.go文件之下进行添加：

```go
//1. 创建一个结构WalletKeyPair秘钥对，保存公钥和私钥
//2. 给这个结构提供一个方法GetAddress：私钥->公钥->地址

type WalletKeyPair struct {
	PrivateKey *ecdsa.PrivateKey

	//将公钥的X，Y进行字节流拼接后传输，这样在对端再进行切割还原，好处是可以方便后面的编码
	PublicKey []byte
}

```

对于钱包，公钥，私钥的创建：

```go
func NewWalletKeyPair() *WalletKeyPair {
    
	privateKey, err := ecdsa.GenerateKey(elliptic.P256(), rand.Reader)
	if err != nil {
		log.Panic(err)
	}
	publicKeyRaw := privateKey.PublicKey
	publicKey := append(publicKeyRaw.X.Bytes(), publicKeyRaw.Y.Bytes()...)
	return &WalletKeyPair{PrivateKey: privateKey, PublicKey: publicKey}
}
```

## 创建钱包地址

大致思路：

![image-20210902144225617](C:\Users\13375\OneDrive\桌面\实习文档\BlockchainDemo\SimpleBlockchainDemoV5\笔记\image-20210902144225617.png)

实现：

添加依赖：

```
go get golang.org/x/crypto/ripemd160
```

计算 20byte 的public hash key

```go
func HashPubKey(pubKey []byte) []byte {
	hash := sha256.Sum256(pubKey)
	//创建一个hash160对象
	//向hash160中write数据
	//做哈希运算
	rip160Haher := ripemd160.New()
	_, err := rip160Haher.Write(hash[:])
	if err != nil {
		log.Panic(err)
	}
	//Sum函数 Sum参数append到一起返回，传入nil
	publicHash := rip160Haher.Sum(nil)
	return publicHash
}
```

根据上述 21byte 进行hash转为 4byte 检验码

```go
func CheckSum(payload []byte) []byte {
	first := sha256.Sum256(payload)
	second := sha256.Sum256(first[:])
	//4字节校验码
	checksum := second[0:4]
	return checksum
}
```

实现：

```go
func (w *WalletKeyPair) GetAddress() string {

	publicHash := HashPubKey(w.PublicKey)
	version := 0x00
	//21字节的数据
	payload := append([]byte{byte(version)}, publicHash...)
	checksum := CheckSum(payload)
	//25字节
	payload = append(payload, checksum...)
	address := base58.Encode(payload)
	return address
}
```

测试：

```
$ SimpleBlockchainDemoV5 createWallet

创建钱包命令被调用
钱包文件不存在，准备创建!
新的钱包地址为: 1FXhypuwFUJM8sfv426GxVVrUnwaz1HtSG

```

## 对于钱包进行持久化保护

实现wallets.go

- 使用map把地址和密钥进行保存
- 持久化保存对于map进行保存

实现：

```go
package main

import (
	"bytes"
	"crypto/elliptic"
	"encoding/gob"
	"fmt"
	"io/ioutil"
)

type Wallets struct {
	WalletsMap map[string]*WalletKeyPair
}

//创建Wallets, 返回Wallets的实例
func NewWallets() *Wallets {
	var ws Wallets
	ws.WalletsMap = make(map[string]*WalletKeyPair)
	//1. 把所有的钱包从本地加载出来
	if !ws.LoadFromFile() {
		fmt.Printf("加载钱包数据失败!\n")
	}
	//2. 把实例返回
	return &ws
}
```

```go

//Wallets调用WalletKeypPair
func (ws *Wallets) CreateWallet() string {
   //滴啊用NewWalletKeyPair
   wallet := NewWalletKeyPair()
   //将返回的walletKeypair添加到WalletMap中
   address := wallet.GetAddress()
   ws.WalletsMap[address] = wallet
   //保存到本地文件
   res := ws.SaveToFile()
   if !res {
      fmt.Printf("创建钱包失败!\n")
      return ""
   }
   return address
}
```

## 本地保存

wallets.go 文件之下对于钱包进行保存

```go
//保存钱包到文件
func (ws *Wallets) SaveToFile() bool {
   var buffer bytes.Buffer
   gob.Register(elliptic.P256())
   encoder := gob.NewEncoder(&buffer)
   err := encoder.Encode(ws)
   if err != nil {
      fmt.Printf("钱包序列化失败!, err: %v\n", err)
      return false
   }
   content := buffer.Bytes()
   err = ioutil.WriteFile(WalletName, content, 0600)
   if err != nil {
      fmt.Printf("钱包创建失败!\n")
      return false
   }
   return true
}
```

## 钱包迭代加载

wallets.go 文件之下对于钱包进行迭代加载

```go
func (ws *Wallets) LoadFromFile() bool {
   //判断文件是否存在
   if !IsFileExist(WalletName) {
      fmt.Printf("钱包文件不存在，准备创建!\n")
      return true
   }
   //读取文件
   content, err := ioutil.ReadFile(WalletName)
   if err != nil {
      return false
   }
   gob.Register(elliptic.P256())
   decoder := gob.NewDecoder(bytes.NewReader(content))
   var wallets Wallets
   err = decoder.Decode(&wallets)
   if err != nil {
      fmt.Printf("err : %v\n", err)
      return false
   }
   ws.WalletsMap = wallets.WalletsMap
   return true
}
```

## 获取所有地址

wallets.go 文件之下对于钱包获取所有钱包地址，进行查看

```go
func (ws *Wallets) ListAddress() []string {
   //遍历ws.WalletsMap结构返回key即可
   var addresses []string
   for address, _ := range ws.WalletsMap {
      addresses = append(addresses, address)
   }
   return addresses
}
```

## 使用地址，密钥进行改写

transaction.go 文件对于交易结构进行改写：

```go
type TXInput struct {
   TXID []byte //交易id
   Index int64 //output的索引
   Signature []byte //交易签名
   PubKey []byte //公钥本身，不是公钥哈希
}

type TXOutput struct {
   Value float64 //转账金额
   PubKeyHash []byte //是公钥的哈希，不是公钥本身
    
}
```

我们转账的时候使用的是地址，根据hash推导出地址

## 实现NewTXOutput

给定转账地址，得到这个地址的公钥哈希，完成对output的锁定

```go

func (output *TXOutput) Lock(address string) {
   //address -> public key hash
   decodeInfo := base58.Decode(address)
   pubKeyHash := decodeInfo[1:len(decodeInfo)-4]
   output.PubKeyHash = pubKeyHash
    
}
```

```go
func NewTXOutput(value float64, address string) TXOutput {
    
   output := TXOutput{Value: value}
   output.Lock(address)
   return output
    
}
```

## 改写NewCoinbaseTx

```go
//实现挖矿挖矿交易，
//特点：只有输出，没有有效的输入(不需要引用id，不需要索引，不需要签名)
//把挖矿的人传递进来，因为有奖励
func NewCoinbaseTx(miner string, data string) *Transaction {

   //我们在后面的程序中，需要识别一个交易是否为coinbase，所以我们需要设置一些特殊的值，用于判断
   inputs := []TXInput{TXInput{nil, -1, nil, []byte(data)}}
   output := NewTXOutput(reward, miner)
   outputs := []TXOutput{output}
   tx := Transaction{nil, inputs, outputs}
   tx.SetTXID()
   return &tx
    
}
```

## 改写NewTransaction

实现思路：

1. 打开钱包，获取秘钥对
2. 获取公钥，私钥
3. 遍历账本，找到属于付款人的合适的金额，把这个outputs找到

```go
func NewTransaction(from, to string, amount float64, bc *BlockChain) *Transaction {
   //1. 打开钱包
   ws := NewWallets()
   //获取秘钥对
   wallet := ws.WalletsMap[from]

   if wallet == nil {
      fmt.Printf("%s 的私钥不存在，交易创建失败!\n", from)
      return nil
   }
   //2. 获取公钥，私钥
   //privateKey := wallet.PrivateKey //目前使用不到，步骤三签名时使用
   publickKey := wallet.PublicKey
   pubKeyHash := HashPubKey(wallet.PublicKey)
   utxos := make(map[string][]int64) //标识能用的utxo
   var resValue float64              //这些utxo存储的金额
   //1. 遍历账本，找到属于付款人的合适的金额，把这个outputs找到
   utxos, resValue = bc.FindNeedUtxos(pubKeyHash, amount)
   //2. 如果找到钱不足以转账，创建交易失败。
   if resValue < amount {
      fmt.Printf("余额不足，交易失败!\n")
      return nil
   }

   var inputs []TXInput
   var outputs []TXOutput

   //3. 将outputs转成inputs
   for txid , indexes := range utxos {
      for _, i := range indexes {
         input := TXInput{[]byte(txid), i, nil, publickKey}
         inputs = append(inputs, input)
      }
   }

   //4. 创建输出，创建一个属于收款人的output
   output := NewTXOutput(amount, to)
   outputs = append(outputs, output)

   //5. 如果有找零，创建属于付款人output
   if resValue > amount {
      output1 := NewTXOutput(resValue-amount, from)
      outputs = append(outputs, output1)
   }
   //创建交易
   tx := Transaction{nil, inputs, outputs}
   //6. 设置交易id
   tx.SetTXID()
   //7. 返回交易结构
   return &tx
}
```

## 使用HashPubKey改写GetAddress

wallet.go 文件之下：

```go
func HashPubKey(pubKey []byte) []byte {
   hash := sha256.Sum256(pubKey)
   rip160Haher := ripemd160.New()
   _, err := rip160Haher.Write(hash[:])

   if err != nil {
      log.Panic(err)
   }
   //Sum函数 Sum参数append到一起返回，传入nil
   publicHash := rip160Haher.Sum(nil)
   return publicHash
}
```

```go
func (w *WalletKeyPair) GetAddress() string {

   publicHash := HashPubKey(w.PublicKey)
   version := 0x00
   //21字节的数据
   payload := append([]byte{byte(version)}, publicHash...)
   checksum := CheckSum(payload)
   //25字节
   payload = append(payload, checksum...)
   address := base58.Encode(payload)
   return address
}
```

## 交易签名

我们对一笔交易签名，要填充每一个input的sig, N个input要有N个 签名
签名内容包括:

1. 所引用的output的公钥哈希
2. 所新生成的output的公钥哈希
3. 所新生成的output的value

![image-20210906145704379](C:\Users\13375\OneDrive\桌面\实习文档\BlockchainDemo\SimpleBlockchainDemoV5\笔记\image-20210906145704379.png)

![image-20210906145805986](C:\Users\13375\OneDrive\桌面\实习文档\BlockchainDemo\SimpleBlockchainDemoV5\笔记\image-20210906145805986.png)

实现：

```go
//第一个参数时私钥，
//第二个参数时这个交易的input所引用的所有的交易
func (tx *Transaction) Sign(privKey *ecdsa.PrivateKey, prevTXs map[string]Transaction) {
	fmt.Printf("对交易进行签名...\n")

	//校验的时候，如果是挖矿交易，直接返回true
	if tx.IsCoinbase() {
		return
	}

	//1. 拷贝一份交易txCopy，
	// >做相应裁剪：把每一个input的Sig和pubkey设置为nil
	// > output不做改变
	txCopy := tx.TrimmedCopy()

	//2. 遍历txCopy.inputs，
	// > 把这个input所引用的output的公钥哈希拿过来，赋值给pubkey

	for i, input := range txCopy.TXInputs {
		//找到引用的交易
		preTX := prevTXs[string(input.TXID)]
		output := preTX.TXOutputs[input.Index]

		//for循环迭代出来的数据是一个副本，对这个input进行修改，不会影响到原始数据
		//所以我们这里需要使用下标方式修改

		//input.PubKey = output.PubKeyHash
		txCopy.TXInputs[i].PubKey = output.PubKeyHash

		//签名要对数据的hash进行签名
		//我们的数据都在交易中，我们要求交易的哈希
		//Transaction的SetTXID函数就是对交易的哈希
		//所以我们可以使用交易id作为我们的签名的内容

		//3. 生成要签名的数据（哈希）
		txCopy.SetTXID()
		signData := txCopy.TXid

		//清理,原理同上
		//input.PubKey = nil
		txCopy.TXInputs[i].PubKey = nil

		fmt.Printf("要签名的数据， signData: %x\n", signData)

		//4. 对数据进行签名r, s
		r, s, err := ecdsa.Sign(rand.Reader, privKey, signData)

		if err != nil {
			fmt.Printf("交易签名失败, err : %v\n", err)
			//return false
		}

		//5. 拼接r,s为字节流
		signature := append(r.Bytes(), s.Bytes()...)

		//6. 赋值给原始的交易的Signature字段
		tx.TXInputs[i].Signature = signature
	}
	//return true
}
```

## 实现SignTransaction函数

```go
func (bc *BlockChain) SignTransaction(tx *Transaction, privateKey *ecdsa.PrivateKey) {
	//1. 遍历账本找到所有应用交易

	prevTXs := make(map[string]Transaction)

	//遍历tx的inputs，通过id去查找所引用的交易
	for _, input := range tx.TXInputs {
		prevTx := bc.FindTransaction(input.TXID)

		if prevTx == nil {
			fmt.Printf("没有找到交易: %x\n", input.TXID)
		} else {
			prevTXs[string(input.TXID)] = *prevTx
		}
	}

	tx.Sign(privateKey, prevTXs)
}

func (bc *BlockChain) VerifyTransaction(tx *Transaction) bool {

	//校验的时候，如果是挖矿交易，直接返回true
	if tx.IsCoinbase() {
		return true
	}

	prevTXs := make(map[string]Transaction)

	//遍历tx的inputs，通过id去查找所引用的交易
	for _, input := range tx.TXInputs {
		prevTx := bc.FindTransaction(input.TXID)

		if prevTx == nil {
			fmt.Printf("没有找到交易: %x\n", input.TXID)
		} else {
			//把找到的引用交易保存起来
			//0x222
			//0x333
			prevTXs[string(input.TXID)] = *prevTx
		}
	}

	return tx.Verify(prevTXs)
}
```

## 实现FindTransaction函数

遍历区块链的交易  通过对比id来识别

```go
func (bc *BlockChain) FindTransaction(txid []byte) *Transaction {

	//遍历区块链的交易
	//通过对比id来识别

	it := bc.NewIterator()

	for {
		block := it.Next()

		for _, tx := range block.Transactions {

			//如果找到相同id交易，直接返回交易即可
			if bytes.Equal(tx.TXid, txid) {
				fmt.Printf("找到了所引用交易: %x\n", tx.TXid)
				return tx
			}
		}

		if len(block.PrevBlockHash) == 0 {
			break
		}
	}

	return nil
}

```

## 矿工校验

矿工校验流程

1. 找到交易input所引用的所有的交易prevTXs
2. 对交易进行校验

实现：

```go
func (bc *BlockChain) VerifyTransaction(tx *Transaction) bool {

	//校验的时候，如果是挖矿交易，直接返回true
	if tx.IsCoinbase() {
		return true
	}

	prevTXs := make(map[string]Transaction)

	//遍历tx的inputs，通过id去查找所引用的交易
	for _, input := range tx.TXInputs {
		prevTx := bc.FindTransaction(input.TXID)

		if prevTx == nil {
			fmt.Printf("没有找到交易: %x\n", input.TXID)
		} else {
			//把找到的引用交易保存起来
			prevTXs[string(input.TXID)] = *prevTx
		}
	}

	return tx.Verify(prevTXs)
}

```

## Sign实现

签名的过程

![image-20210906145805986](C:\Users\13375\OneDrive\桌面\实习文档\BlockchainDemo\SimpleBlockchainDemoV5\笔记\image-20210906145805986.png)

实现：

```go

func (tx *Transaction) Sign(privKey *ecdsa.PrivateKey, prevTXs map[string]Transaction) {
	fmt.Printf("对交易进行签名...\n")

	//校验的时候，如果是挖矿交易，直接返回true
	if tx.IsCoinbase() {
		return
	}

	//1. 拷贝一份交易txCopy，
	// >做相应裁剪：把每一个input的Sig和pubkey设置为nil
	// > output不做改变
	txCopy := tx.TrimmedCopy()

	//2. 遍历txCopy.inputs，
	// > 把这个input所引用的output的公钥哈希拿过来，赋值给pubkey

	for i, input := range txCopy.TXInputs {
		//找到引用的交易
		preTX := prevTXs[string(input.TXID)]
		output := preTX.TXOutputs[input.Index]
		txCopy.TXInputs[i].PubKey = output.PubKeyHash
		//3. 生成要签名的数据（哈希）
		txCopy.SetTXID()
		signData := txCopy.TXid

		//清理,原理同上
		//input.PubKey = nil
		txCopy.TXInputs[i].PubKey = nil

		fmt.Printf("要签名的数据， signData: %x\n", signData)

		//4. 对数据进行签名r, s
		r, s, err := ecdsa.Sign(rand.Reader, privKey, signData)

		if err != nil {
			fmt.Printf("交易签名失败, err : %v\n", err)
			//return false
		}

		//5. 拼接r,s为字节流
		signature := append(r.Bytes(), s.Bytes()...)

		//6. 赋值给原始的交易的Signature字段
		tx.TXInputs[i].Signature = signature
	}
	//return true
}
```



## 矿工校验

```go
func (tx *Transaction) Verify(prevTXs map[string]Transaction) bool {
	fmt.Printf("对交易进行校验...\n")
	//1. 拷贝修剪的副本
	txCopy := tx.TrimmedCopy()

	//2. 遍历原始交易（注意，不是txCopy)
	for i, input := range tx.TXInputs {

		//3. 遍历原始交易的input所引用的前交易prevTX
		prevTX := prevTXs[string(input.TXID)]
		output := prevTX.TXOutputs[input.Index]

		//4. 找到output的公钥哈希，赋值给txCopy对应的input
		txCopy.TXInputs[i].PubKey = output.PubKeyHash

		//5. 还原签名的数据
		txCopy.SetTXID()

		//清理动作，重要！！！
		txCopy.TXInputs[i].PubKey = nil

		verifyData := txCopy.TXid
		fmt.Printf("verifyData : %x\n", verifyData)

		//6. 校验
		//还原签名为r,s
		signature := input.Signature

		//公钥字节流
		pubKeyBytes := input.PubKey

		r := big.Int{}
		s := big.Int{}

		rData := signature[: len(signature)/2]
		sData := signature[len(signature)/2:]

		r.SetBytes(rData)
		s.SetBytes(sData)


		//还原公钥为curve，X，Y
		x := big.Int{}
		y := big.Int{}

		xData := pubKeyBytes[: len(pubKeyBytes)/2]
		yData := pubKeyBytes[len(pubKeyBytes)/2:]

		x.SetBytes(xData)
		y.SetBytes(yData)

		curve := elliptic.P256()

		publicKey := ecdsa.PublicKey{curve, &x, &y}

		//数据，签名，公钥准备完毕，开始校验
		//func Verify(pub *PublicKey, hash []byte, r, s *big.Int) bool {
		if !ecdsa.Verify(&publicKey, verifyData, &r, &s) {
			return false
		}
	}

	return true
}
```

## 打印交易

实现 查看具体的详细信息

```go
func (tx *Transaction) String() string {
	var lines []string

	lines = append(lines, fmt.Sprintf("--- Transaction %x:", tx.TXid))

	for i, input := range tx.TXInputs {

		lines = append(lines, fmt.Sprintf("     Input %d:", i))
		lines = append(lines, fmt.Sprintf("       TXID:      %x", input.TXID))
		lines = append(lines, fmt.Sprintf("       Out:       %d", input.Index))
		lines = append(lines, fmt.Sprintf("       Signature: %x", input.Signature))
		lines = append(lines, fmt.Sprintf("       PubKey:    %x", input.PubKey))
	}

	for i, output := range tx.TXOutputs {
		lines = append(lines, fmt.Sprintf("     Output %d:", i))
		lines = append(lines, fmt.Sprintf("       Value:  %f", output.Value))
		lines = append(lines, fmt.Sprintf("       Script: %x", output.PubKeyHash))
	}

	return strings.Join(lines, "\n")
}

```

