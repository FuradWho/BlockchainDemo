# 简易区块链V4

## 交易转账

比特币的数据库中只有交易，没有这个用来集中保存用户基本信息的数据表，也就是没有地方存储账户，没有地方存储余额那么比特币系统如何维护我们的钱呢?请看面这张图。每个交易要以以前的交易为基础，而不是以以特定字段记录的余额为基础，而是一切都在交易记录中

![image-20210830151008714](C:\Users\13375\OneDrive\桌面\实习文档\BlockchainDemo\SimpleBlockchainDemoV4\image-20210830151008714.png)

我们的钱零散的分布在不同的交易中。如果想要知道某个地址的余额，那就需要遍历整个账本，把所有属于整个地址的钱统计累加。

## 找零机制

那张三的钱如何扣除呢?去上笔交易中修改数据么?比特币是防篡改的，那怎么办?解决办法:把_上笔交易中张三的钱全部花掉，扣除转给李四的钱，余额转给自己，对，就是自己转给自己。这类似于我们现实生活中的找零机制!

![image-20210830151139939](C:\Users\13375\OneDrive\桌面\实习文档\BlockchainDemo\SimpleBlockchainDemoV4\image-20210830151139939.png)

## 手续费

大多数交易包含交易费(矿工费)，这是为了确保网络安全而给比特币矿工的一种补偿。费用本身也作为一个安全机制，使经济.上不利于攻击者通过交易来淹没网络。交易费作为矿工打包(挖矿)一笔交易到下一个区块中的一种激励;同时作为-种抑制因素，通过对每一笔交易收取小额费用来防止对系统的滥用。成功挖到某区块的矿工将得到该区内包含的矿工费，并将该区块添加至区块链中。

交易费是基于交易的千字节规模来计算的，而不是比特币交易的价值。

交易的数据结构没有交易费的字段。相替代地，交易费是指输入和输出之间的差值。从所有输入中扣掉所有输出之后的多余的量会被矿工作为矿工费收集。

**交易费即输入总和减输出总和的余量:交易费=求和(所有输入) -求和(所有输出)** 

### 一对一

![image-20210830151315030](C:\Users\13375\OneDrive\桌面\实习文档\BlockchainDemo\SimpleBlockchainDemoV4\image-20210830151315030.png)

### 多对一

![image-20210830151347956](C:\Users\13375\OneDrive\桌面\实习文档\BlockchainDemo\SimpleBlockchainDemoV4\image-20210830151347956.png)

## 定义交易结构

### 交易输入(TXInput)

指明交易发起人可支付资金的来源，包含:

- 引用utxo所在交易的ID (知道在哪个房间)
- 所消费utxo在output中的索引(具 体位置)
- 解锁脚本(签名，公钥)

### 交易输出(TXOutput)

包含资金接收方的相关信息,包含:

- 接收金额(数字)
- 锁定脚本(对方公钥的哈希，这个哈希可以通过地址反推出来，所以转账时知道地址即可! )

### 交易ID

一般是交易结构的哈希值(参考block的哈希做法)

transaction.go

```go
/*
	定义交易结构
	定义input
	定义output
	设置交易ID
 */

type TXInput struct {
	TXID    []byte //交易id
	Index   int64  //output的索引
	Address string //解锁脚本，先使用地址来模拟
}

type TXOutput struct {
	Value   float64 //转账金额
	Address string  //锁定脚本
}

type Transaction struct {
	TXid      []byte     //交易id
	TXInputs  []TXInput  //所有的inputs
	TXOutputs []TXOutput //所有的outputs
}
```

### SetTXID函数

设置交易ID

transaction.go

```go
func (tx *Transaction) SetTXID() {

	var buffer bytes.Buffer

	encoder := gob.NewEncoder(&buffer)

	err := encoder.Encode(tx)

	if err != nil {
		log.Panic(err)
	}

	hash := sha256.Sum256(buffer.Bytes())
	tx.TXid = hash[:]
}
```

## 实现挖矿交易

特点：只有输出，没有有效的输入（不需要引用id，不需要索引，不需要签名）

transaction.go

```go
//把挖矿的人传递进来，因为有奖励
func NewCoinbaseTx(miner string, data string) *Transaction {

	//我们在后面的程序中，需要识别一个交易是否为coinbase，所以我们需要设置一些特殊的值，用于判断
	inputs := []TXInput{TXInput{nil, -1, data}}
	outputs := []TXOutput{TXOutput{12.5, miner}}

	tx := Transaction{nil, inputs, outputs}
	tx.SetTXID()

	return &tx
}
```

## 使用Transaction对于程序进行改写

因为我们之前是使用Data进行交易的替代，所以这里面我们使用Transaction数组进行改写。

block.go

```go
package main

import (
	"bytes"
	"encoding/gob"
	"fmt"
	"github.com/boltdb/bolt"
	"log"
	"os"
	"time"
)

/*
大致流程：

	1. 定义结构（区块头的字段比正常的少）
		1. 前区块哈希
		2. 当前区块哈希
		3. 数据
	2. 创建区块
	3. 生成哈希
	4. 引入区块链
	5. 添加区块
	6. 重构代码

*/

const genesisInfo = "The Times 03/Jan/2009 Chancellor on brink of second bailout for banks"

// 1.定义结构（区块头的字段比正常的少）
type Block struct {
	Version       uint64 //区块版本号
	PrevBlockHash []byte //前区块哈希
	MerKleRoot    []byte //先填写为空，后续使用
	TimeStamp     uint64 //从1970.1.1至今的秒数
	Difficulity   uint64 //挖矿的难度值, v2时使用
	Nonce         uint64 //随机数，挖矿找的就是它!
	//Data          []byte //数据，目前使用字节流，v4开始使用交易代替
	Hash          []byte //当前区块哈希, 区块中本不存在的字段，为了方便我们添加进来

	Transactions []*Transaction
}

// 2. 创建区块
func NewBlock(txs []*Transaction, prevBlockHash []byte) *Block {

	block := Block{
		Version:       00,
		PrevBlockHash: prevBlockHash,
		MerKleRoot:    []byte{},
		TimeStamp:     uint64(time.Now().Unix()),
		Difficulity:   Bits, //随便写的，后续调整
		//Data:          []byte(data),
		Transactions: txs,
		Hash:          []byte{}, //先填充为空，后续会填充数据
	}

	// block.SetHash() 生成Hash值

	pow := NewProofOfWork(&block)
	hash, nonce := pow.Run()

	block.Hash = hash
	block.Nonce = nonce

	return &block
}

//序列化, 将区块转换成字节流
func (block *Block) Serialize() []byte {

	var buffer bytes.Buffer

	//定义编码器
	encoder := gob.NewEncoder(&buffer)

	//编码器对结构进行编码，一定要进行校验
	err := encoder.Encode(block)
	if err != nil {
		log.Panic(err)
	}

	return buffer.Bytes()
}

func Deserialize(data []byte) *Block {

	fmt.Printf("解码传入的数据: %x\n", data)

	var block Block

	//创建解码器
	decoder := gob.NewDecoder(bytes.NewReader(data))
	err := decoder.Decode(&block)

	if err != nil {
		log.Panic(err)
	}

	return &block
}

//定义一个区块链的迭代器，包含db，current
type BlockChainIterator struct {
	db      *bolt.DB
	current []byte //当前所指向区块的哈希值
}

//创建迭代器，使用bc进行初始化

func (bc *BlockChain) NewIterator() *BlockChainIterator {
	return &BlockChainIterator{bc.db, bc.tail}
}

func (it *BlockChainIterator) Next() *Block {

	var block Block

	it.db.View(func(tx *bolt.Tx) error {

		b := tx.Bucket([]byte(blockBucketName))
		if b == nil {
			fmt.Printf("bucket不存在，请检查!\n")
			os.Exit(1)
		}

		//读取数据
		blockInfo := b.Get(it.current)
		block = *Deserialize(blockInfo)

		it.current = block.PrevBlockHash

		return nil
	})

	return &block
}

```

blockchain.go

```go
package main

import (
	"fmt"
	"github.com/boltdb/bolt"
	"log"
	"os"
)

// 使用bolt改写
type BlockChain struct {
	db   *bolt.DB //数据库的一个句柄
	tail []byte   //最后一个区块的Hash值

}

const blockChainName = "blockChain.db"
const blockBucketName = "blockBucket"
const lastHashKey = "lastHashKey"

// 实现创建区块链的方法
func NewBlockChain(miner string) *BlockChain {

	//功能分析：
	//1. 获得数据库的句柄，打开数据库，读写数据
	db, err := bolt.Open(blockChainName, 0600, nil)
	//向数据库中写入数据
	//从数据库中读取数据

	if err != nil {
		log.Panic(err)
	}

	//defer db.Close()

	var tail []byte

	db.Update(func(tx *bolt.Tx) error {
		b := tx.Bucket([]byte(blockBucketName))

		if b == nil {
			//如果b1为空，说明名字为"buckeName1"这个桶不存在，我们需要创建之
			fmt.Printf("bucket不存在，准备创建!\n")
			b, err = tx.CreateBucket([]byte(blockBucketName))

			if err != nil {
				log.Panic(err)
			}

			//抽屉准备完毕，开始添加创世块

			coinbase := NewCoinbaseTx(miner)

			genesisBlock := NewBlock([]*Transaction{coinbase}, []byte{})
			b.Put(genesisBlock.Hash, genesisBlock.Serialize() /*将区块序列化，转成字节流*/)
			b.Put([]byte(lastHashKey), genesisBlock.Hash)

			//为了测试，我们把写入的数据读取出来，如果没问题，注释掉这段代码
			//blockInfo := b.Get(genesisBlock.Hash)
			//block := Deserialize(blockInfo)
			//fmt.Printf("解码后的block数据:%s\n", block)

			tail = genesisBlock.Hash
		} else {
			tail = b.Get([]byte(lastHashKey))
		}

		return nil
	})

	return &BlockChain{db, tail}

}

// 5. 添加区块
func (bc *BlockChain) AddBlock(txs []*Transaction) {
	//1. 创建一个区块
	bc.db.Update(func(tx *bolt.Tx) error {
		b := tx.Bucket([]byte("blockBucket"))

		if b == nil {
			fmt.Printf("bucket不存在，请检查!\n")
			os.Exit(1)
		}

		block := NewBlock(txs, bc.tail)
		b.Put(block.Hash, block.Serialize() /*将区块序列化，转成字节流*/)
		b.Put([]byte("lastHashKey"), block.Hash)

		bc.tail = block.Hash

		return nil
	})
}

//实现思路：
//

func (bc *BlockChain) FindMyUtoxs(address string) []TXOutput {
	fmt.Printf("FindMyUtoxs\n")
	var UTXOs []TXOutput //返回的结构

	it := bc.NewIterator()

	//这是标识已经消耗过的utxo的结构，key是交易id，value是这个id里面的output索引的数组
	spentUTXOs := make(map[string][]int64)

	//1. 遍历账本
	for {

		block := it.Next()

		//2. 遍历交易
		for _, tx := range block.Transactions {
			//遍历交易输入:inputs

			for _, input := range tx.TXInputs {
				if input.Address == address {
					fmt.Printf("找到了消耗过的output! index : %d\n", input.Index)
					key := string(input.TXID)
					spentUTXOs[key] = append(spentUTXOs[key], input.Index)
					//spentUTXOs[0x222] = []int64{0}
					//spentUTXOs[0x333] = []int64{0}  //中间状态
					//spentUTXOs[0x333] = []int64{0, 1}
				}
			}

			key := string(tx.TXid)
			indexes /*[]int64{0,1}*/ := spentUTXOs[key]

		OUTPUT:
			//3. 遍历output
			for i, output := range tx.TXOutputs {

				if len(indexes) != 0 {
					fmt.Printf("当前这笔交易中有被消耗过的output!\n")
					for _, j /*0, 1*/ := range indexes {
						if int64(i) == j {
							fmt.Printf("i == j, 当前的output已经被消耗过了，跳过不统计!\n")
							continue OUTPUT
						}
					}
				}

				//4. 找到属于我的所有output
				if address == output.Address {
					fmt.Printf("找到了属于 %s 的output, i : %d\n", address, i)
					UTXOs = append(UTXOs, output)
				}
			}
		}

		if len(block.PrevBlockHash) == 0 {
			fmt.Printf("遍历区块链结束!\n")
			break
		}
	}

	return UTXOs
}

func (bc *BlockChain) GetBalance(address string) {
	utxos := bc.FindMyUtoxs(address)

	var total = 0.0

	for _, utxo := range utxos {
		total += utxo.Value //10, 3, 1
	}

	fmt.Printf("%s 的余额为: %f\n", address, total)
}

//1. 遍历账本，找到属于付款人的合适的金额，把这个outputs找到
//utxos, resValue = bc.FindNeedUtxos(from, amount)
func (bc *BlockChain) FindNeedUtxos(from string, amount float64) (map[string][]int64, float64) {

	needUtxos := make(map[string][]int64) //标识能用的utxo, //返回的结构
	var resValue float64                  //统计的金额

	it := bc.NewIterator()

	//这是标识已经消耗过的utxo的结构，key是交易id，value是这个id里面的output索引的数组
	spentUTXOs := make(map[string][]int64)

	//1. 遍历账本
	for {

		block := it.Next()

		//2. 遍历交易
		for _, tx := range block.Transactions {
			//遍历交易输入:inputs

			for _, input := range tx.TXInputs {
				if input.Address == from {
					fmt.Printf("找到了消耗过的output! index : %d\n", input.Index)
					key := string(input.TXID)
					spentUTXOs[key] = append(spentUTXOs[key], input.Index)
					//spentUTXOs[0x222] = []int64{0}
					//spentUTXOs[0x333] = []int64{0}  //中间状态
					//spentUTXOs[0x333] = []int64{0, 1}
				}
			}

			key := string(tx.TXid)
			indexes /*[]int64{0,1}*/ := spentUTXOs[key]

		OUTPUT:
			//3. 遍历output
			for i, output := range tx.TXOutputs {

				if len(indexes) != 0 {
					fmt.Printf("当前这笔交易中有被消耗过的output!\n")
					for _, j /*0, 1*/ := range indexes {
						if int64(i) == j {
							fmt.Printf("i == j, 当前的output已经被消耗过了，跳过不统计!\n")
							continue OUTPUT
						}
					}
				}

				//4. 找到属于我的所有output
				if from == output.Address {
					fmt.Printf("找到了属于 %s 的output, i : %d\n", from, i)
					//UTXOs = append(UTXOs, output)
					//在这里实现控制逻辑
					//找到符合条件的output
					//1. 添加到返回结构中needUtxos
					needUtxos[key] = append(needUtxos[key], int64(i))
					resValue += output.Value

					//2. 判断一下金额是否足够
					if resValue >= amount {
						//a. 足够， 直接返回
						return needUtxos, resValue
					}
					//b. 不足， 继续遍历
				}
			}
		}

		if len(block.PrevBlockHash) == 0 {
			fmt.Printf("遍历区块链结束!\n")
			break
		}
	}

	return needUtxos, resValue
}


```

## HashTransaction实现

区块的完整图示：

比特币做哈希值，并不是对整个区块做哈希，而是对区块头做哈希

![image-20210830153714047](C:\Users\13375\OneDrive\桌面\实习文档\BlockchainDemo\SimpleBlockchainDemoV4\image-20210830153714047.png)

block.go 进行模拟实现：

```go
//模拟梅克尔根，做一个简单的处理
func (block *Block) HashTransactions() {
	//我们的交易的id就是交易的哈希值，所以我们可以将交易id拼接起来，整体做一次个哈希运算，作为MerKleRoot

	var hashes []byte

	for _, tx := range block.Transactions {
		txid := tx.TXid
		hashes = append(hashes, txid...)
	}

	hash := sha256.Sum256(hashes)
	block.MerKleRoot = hash[:]
}
```

