# 简易区块链V3

## 大致思路

1. 使用数据库进行数据保存，读取
2. 命令行人机交互

## Bolt 轻量级数据库

github 地址：https://github.com/bolt/bolt

官方文档： https://docs.bolt.cm/4.0/installation/installation

Bolt 是由 Howard Chu 的 [LMDB](https://link.jianshu.com/?t=https%3A%2F%2Fsymas.com%2Flmdb%2Ftechnical%2F) 项目启发的一个纯粹的 Go key/value数据库。 该项目的目标是为不需要完整数据库服务器（如Postgres或MySQL）的项目提供一个简单，快速和可靠的数据库。

由于 Bolt 是用来作为这样一个低层次的功能，简单是关键。 该API将是小的，只专注于获取值和设置值而已。

大致原理：

我们可以把一个数据库看做为一个柜子，柜子里的每一抽屉就是一个bucket（桶）储存单元，真正的数据都是放在一个bucket里面。

![image-20210825133428304](C:\Users\13375\OneDrive\桌面\实习文档\BlockchainDemo\SimpleBlockchainDemoV3\image-20210825133428304.png)

![image-20210825133655687](C:\Users\13375\OneDrive\桌面\实习文档\BlockchainDemo\SimpleBlockchainDemoV3\image-20210825133655687.png)

## Bolt 数据库使用Demo

使用命令对于数据库包进行拉取：

```go
go get github.com/boltdb/bolt/...
```

根据我们上面的原理：

下面是 Bolt 的主要入口点：

- `bolt.Open()` - 初始化数据库。如果数据库不存在负责创建数据库，获得文件的一个排他锁，读取元页面并且完成文件内存映射。
- `DB.Begin()` - 根据 `writeable` 参数，开始一个只读或者读写事务。这需要简单地获取“元”锁来跟踪未完成的事务。一次只能存在一个读写事务，所以在读写事务周期中需要获得“rwlock”。
- `Bucket.Put()` - 将键值对写入一个桶中，检查入参之后，用一个游标遍历页面的和位置的 B+ 树，这个位置被用来写入键值对。一旦找到位置，存储桶将底层页面和页面的父页面作为“节点”物化到内存中中。这些节点是在读写事务期间发生变化的地方。这些更改在提交时刷新到磁盘。
- `Bucket.Get()` - 从存储桶中或者键值对。使用游标来移动到键值对所在的页面和位置。在只读事务期间，键值对被直接从底层 mmap 文件的引用返回，所以没有分配的开销。对于读写事务，此数据可能会引用 mmap 文件或其中一个内存中节点值。
- `Tx.Commit()` - 将内存中的脏节点和空闲页列表转换为要写入磁盘的页面。磁盘写入发生在两个阶段。第一，脏页面被吸入到磁盘并且会调用`fsync`。第二，一个新的增加事务 ID 元页面被写入并且调用`fsync`。这两个阶段的写入可以确保部分写入的数据页面在发生崩溃时被忽略，因为指向它的元页面从不写入。部分写入的元页面因为用校验和写入而失效。
- `Cursor` - 这个对象对于磁盘页面和内存节点的遍历很简单，可以查找一个指定的 key，移动到第一个或者最后一个值，可以向前或者向后移动。对用户而言，游标会透明地处理在 B+ 树的上下移动。

boltDemo.go:

```go
package main

import (
	"fmt"
	"github.com/boltdb/bolt"
	"log"
)

func main()  {
	db, err := bolt.Open("test.db", 0600, nil)

	if err != nil{
		log.Panic(err)
	}

	defer db.Close()

	db.Update(func(tx *bolt.Tx) error {
		//新建一个bucket
		b1 := tx.Bucket([]byte("bucketName1"))

		if b1 == nil {
			//如果b1为空，说明名字为"buckeName1"这个桶不存在，我们需要创建
			b1, err = tx.CreateBucket([]byte("bucketName1"))

			if err != nil {
				log.Panic(err)
			}
		}
		//bucket已经创建完成，准备写入
		err = b1.Put([]byte("name1"), []byte("Lily"))
		if err != nil {
			fmt.Printf("写入数据失败name1 : Lily!\n")
		}

		err = b1.Put([]byte("name2"), []byte("Jim"))
		if err != nil {
			fmt.Printf("写入数据失败name2 : Jim!\n")
		}
		//读取数据
		name1 := b1.Get([]byte("name1"))
		name2 := b1.Get([]byte("name2"))
		name3 := b1.Get([]byte("name3"))

		fmt.Printf("name1: %s\n", name1)
		fmt.Printf("name2: %s\n", name2)
		fmt.Printf("name3: %s\n", name3)


		return nil
		
	})
}
```

其中：

```go
db.Update(func(tx *bolt.Tx) error {}
```

这就是数据库的一个事务：

Bolt 一次只允许一个读写事务，但是一次允许多个只读事务。 每个事务处理都有一个始终如一的数据视图。

单个事务以及从它们创建的所有对象（例如bucket，key）不是线程安全的。 要处理多个goroutine 中的数据，您必须为每个 goroutine 启动一个事务，或使用锁来确保一次只有一个 goroutine 访问事务。 从 DB 创建事务是线程安全的。

只读事务和读写事务不应该相互依赖，一般不应该在同一个例程中同时打开。 这可能会导致死锁，因为读写事务需要定期重新映射数据文件，但只有在只读事务处于打开状态时才能这样做。

**读写事务**

```go
err := db.Update(func(tx *bolt.Tx) error {
    ...
    return nil
})
```

 **只读事务**

```go
err := db.View(func(tx *bolt.Tx) error {
    ...
    return nil
})
```



## 使用Bolt对于项目改写的思考

key一定唯一：

把所有的区块都写到一个bucket中：key-> value :        []byte->[]byte   :  

在bucket存储两种数据：

​	1.区块，区块的哈希值作为key，区块的字节流作为value

  		block.Hash -> block.toBytes()

​	2.最后一个区块的哈希值

 		key使用固定的字符串：[]byte("lastHashKey"), value 就是最后一个区块的哈希

==结论==：

添加一个新区块要做两件事情：

- ==添加区块==
- ==更新”lastHashKey“ 这个key对应的值，这个值就是最后一个区块的哈希值，用于新区块的创建添加。==

![image-20210825135113430](C:\Users\13375\OneDrive\桌面\实习文档\BlockchainDemo\SimpleBlockchainDemoV3\image-20210825135113430.png)

## 改写区块链，获取区块链实例

对于 BlockChain 的改写：

首先，我们原本的结构：

```go
type BlockChain struct {
	Blocks []*Block
}
```

我们是使用了一个区块数组去模拟的区块链，但是我们想要去使用数据库的话，就都得使用数据库的一个句柄去找到数据库，以及得到最后一个区块的Hash值：

BlockChain.go:

```go
// 使用bolt改写
type BlockChain struct {
	db *bolt.DB //数据库的一个句柄
	tail []byte //最后一个区块的Hash值

}
```

改写分析：

1. 获取数据库句柄，打开数据库呀，进行读写数据
2. 准备一个bucket，新建一个创始区块
3. 将创始区块进行序列化，转换为字节流，保存到数据库之中

代码实现：BlockChain.go:

```go

const blockChainName = "blockChain.db"
const blockBucketName = "blockBucket"
const lastHashKey = "lastHashKey"

// 实现创建区块链的方法
func NewBlockChain() *BlockChain {

	//功能分析：
	//1. 获得数据库的句柄，打开数据库，读写数据
	db, err := bolt.Open(blockChainName, 0600, nil)
	if err != nil {
		log.Panic(err)
	}
	var tail []byte
	db.Update(func(tx *bolt.Tx) error {
		b := tx.Bucket([]byte(blockBucketName))

		if b == nil {
			//如果b1为空，说明名字为"buckeName1"这个桶不存在，我们需要创建
			fmt.Printf("bucket不存在，准备创建!\n")
			b, err = tx.CreateBucket([]byte(blockBucketName))

			if err != nil {
				log.Panic(err)
			}

			//抽屉准备完毕，开始添加创世块
			genesisBlock := NewBlock(genesisInfo, []byte{})
           	 b.Put(genesisBlock.Hash, genesisBlock.Serialize())
			b.Put([]byte(lastHashKey), genesisBlock.Hash)
			tail = genesisBlock.Hash
		} else {
			tail = b.Get([]byte(lastHashKey))
		}

		return nil
	})

	return &BlockChain{db, tail}

}
```

## gob编码解码

Gob 是Go语言自己以二进制形式序列化和反序列化程序数据的格式，可以在 encoding 包中找到。这种格式的数据简称为 Gob（即 Go binary 的缩写）。类似于 [Python](http://c.biancheng.net/python/) 的“pickle”和 [Java](http://c.biancheng.net/java/) 的“Serialization”。

gob是go语言内置的编码包，它可以对任意数据类型进行编码和解码。编码时，先要创建编码器，编码器进行编码。解码时，先要创建解码器，解码器进行解码

```go
package main

import (
	"encoding/gob"
	"bytes"
	"log"
	"fmt"
)

//1. gob是go语言内置的编码包
//2. 它可以对任意数据类型进行编码和解码
//3. 编码时，先要创建编码器，编码器进行编码
//4. 解码时，先要创建解码器，解码器进行解码
type Person struct {
	Name string
	Age  uint64
}

func main() {

	Jim := Person{
		Name: "Jim",
		Age:  19,
	}

	var buffer bytes.Buffer

	//定义编码器
	encoder := gob.NewEncoder(&buffer)

	//编码器对结构进行编码，一定要进行校验
	err := encoder.Encode(&Jim)
	if err != nil {
		log.Panic(err)
	}
	fmt.Printf("编码后的数据: %x\n", buffer.Bytes())

	//解码，将字节流转换Person结构
	//4. 解码时，先要创建解码器，解码器进行解码
	var p1 Person
	//创建解码器
	decoder := gob.NewDecoder(bytes.NewReader(buffer.Bytes()))
	err = decoder.Decode(&p1)

	if err != nil {
		log.Panic(err)
	}

	fmt.Printf("解码后的数据: %v\n", p1)

}

```

## 区块序列化，反序列化

我们使用上面的demo，对于block进行优化：

block.go 添加序列化，反序列化函数：

```go
//序列化, 将区块转换成字节流
func (block *Block) Serialize() []byte {

	var buffer bytes.Buffer
	//定义编码器
	encoder := gob.NewEncoder(&buffer)
	//编码器对结构进行编码，一定要进行校验
	err := encoder.Encode(block)
	if err != nil {
		log.Panic(err)
	}

	return buffer.Bytes()
}

func Deserialize(data []byte) *Block {
	fmt.Printf("解码传入的数据: %x\n", data)
	var block Block
	//创建解码器
	decoder := gob.NewDecoder(bytes.NewReader(data))
	err := decoder.Decode(&block)

	if err != nil {
		log.Panic(err)
	}

	return &block
}
```

## AddBlock函数改写

其实对于区块的添加大致的原理都是一致的：

1. 我们先去开启一个读写的事务，对于bucket进行是否存在的判断
2. 根据数据新建一个区块
3. 将该区块进行序列化，并且加入数据库
4. 更新数据库的最后一个Hash值

blockChain.go 文件下：

```go
// 5. 添加区块
func (bc *BlockChain) AddBlock(data string) {
	//1. 创建一个区块
	bc.db.Update(func(tx *bolt.Tx) error {
		b := tx.Bucket([]byte("blockBucket"))

		if b == nil {
			fmt.Printf("bucket不存在，请检查!\n")
			os.Exit(1)
		}

		block := NewBlock(data, bc.tail)
		b.Put(block.Hash, block.Serialize())
		b.Put([]byte("lastHashKey"), block.Hash)

		bc.tail = block.Hash

		return nil
	})
}
```

打印输出：

```
bucket不存在，准备创建!
挖矿成功！nonce: 948362, 哈希值为: 00000fbcf2078162273ce499be75cb150d191a4f7a1f04db7932fc48fd46baac
创建一个区块链
挖矿成功！nonce: 288858, 哈希值为: 00000ce3112aaada48c72c346f632ebdb17cc32610361423ae7629a796b6ec69
挖矿成功！nonce: 1745111, 哈希值为: 000006008a2715059823c5c13d58a1fafd92a2767ca1973a36aed7ed238c8ab5
```

## 区块链的迭代读取

迭代器：

迭代器作用:遍历容器，将数据逐个返回，防止一-次性加载到内存，所以一- 点一点读取。类比: for循环里面range

![image-20210825142456285](C:\Users\13375\OneDrive\桌面\实习文档\BlockchainDemo\SimpleBlockchainDemoV3\image-20210825142456285.png)

我们实现分析：

创建一个BlockChain的迭代器， 里面包含两个元素: db, current
		db:为了遍历账本
		current:为了访问每一区块
迭代器要实现一个方法: Next()

每次调用Next方法，做两件事情:
		1.返回当前所指向的区块的数据block
		2.指针向前移动

大致图示：

![image-20210825142740008](C:\Users\13375\OneDrive\桌面\实习文档\BlockchainDemo\SimpleBlockchainDemoV3\image-20210825142740008.png)

### 定义迭代器

我们去定义一个迭代器，包含db，current

```go
//定义一个区块链的迭代器
type BlockChainIterator struct {
	db      *bolt.DB
	current []byte 	//当前所指向区块的哈希值
}

//创建迭代器，使用bc进行初始化
func (bc *BlockChain) NewIterator() *BlockChainIterator {
	return &BlockChainIterator{bc.db, bc.tail}
}
```

### Next方法

实现两件事情：

1. 返回当前区块的数据
2. 指针向前移动

使用db.View() 进行数据的只读，通过Hash作为 key 获取数据

实现：

```go
func (it *BlockChainIterator) Next() *Block {

	var block Block

	it.db.View(func(tx *bolt.Tx) error {

		b := tx.Bucket([]byte(blockBucketName))
		if b == nil {
			fmt.Printf("bucket不存在，请检查!\n")
			os.Exit(1)
		}

		//真正的读取数据
		blockInfo  := b.Get(it.current)
		block = *Deserialize(blockInfo)

		it.current = block.PrevBlockHash

		return nil
	})

	return &block
}
```

### 最终打印实现

main.go文件之中：

思路：

1. 我们先创建区块，在创建之后去获取迭代器。
2. 循环调用Next()方法，读取区块
3. 结束判断就是上一个区块的Hash是否为空

```go
package main

import (
	"bytes"
	"fmt"
	"time"
)

func main() {

	bc := NewBlockChain()
	fmt.Println("创建一个区块链")

	defer bc.db.Close()
	bc.AddBlock("新建一个区块，名字为No.3")
	bc.AddBlock("新建一个区块，名字为No.4")

	it := bc.NewIterator()

	for {
		block := it.Next()

		fmt.Printf("--------------\n")
		fmt.Printf("Version : %d\n", block.Version)
		fmt.Printf("PrevBlockHash : %x\n", block.PrevBlockHash)
		fmt.Printf("MerKleRoot : %x\n", block.MerKleRoot)

		timeFormat := time.Unix(int64(block.TimeStamp), 0).Format("2006-01-02 15:04:05")
		fmt.Printf("TimeStamp : %s\n", timeFormat)
		fmt.Printf("Difficulity : %d\n", block.Difficulity)
		fmt.Printf("Nonce : %d\n", block.Nonce)
		fmt.Printf("Hash : %x\n", block.Hash)
		fmt.Printf("Data : %s\n", block.Data)

		pow := NewProofOfWork(block)
		fmt.Printf("IsValid : %v\n", pow.IsValid())

		if bytes.Equal(block.PrevBlockHash, []byte{}) {
			fmt.Printf("区块链遍历结束!\n")
			break
		}
	}

}

```

打印输出：

```
创建一个区块链
挖矿成功！nonce: 2201098, 哈希值为: 00000e24eb745ebed78303da175b7fd12a91326ddb97d5d38ca1111652380e41
挖矿成功！nonce: 119366, 哈希值为: 0000085aec3c1bf8606c04abfad78b9853774fb6ccf09644b95a7916ffa17baf
解码传入的数据: 7aff8103010105426c6f636b01ff82000108010756657273696f6e010600010d50726576426c6f636b48617368010a00010a4d65724b6c65526f6f74010a00010954696d655374616d70010600010b446966666963756c69747901060001054e6f6e6365010600010444617461010a00010448617368010a00000078ff82022000000e24eb745ebed78303da175b7fd12a91326ddb97d5d38ca1111652380e4102fc6125e5a3011401fd01d2460122e696b0e5bbbae4b880e4b8aae58cbae59d97efbc8ce5908de5ad97e4b8ba4e6f2e3401200000085aec3c1bf8606c04abfad78b9853774fb6ccf09644b95a7916ffa17baf00
--------------
Version : 0
PrevBlockHash : 00000e24eb745ebed78303da175b7fd12a91326ddb97d5d38ca1111652380e41
MerKleRoot : 
TimeStamp : 2021-08-25 14:39:31
Difficulity : 20
Nonce : 119366
Hash : 0000085aec3c1bf8606c04abfad78b9853774fb6ccf09644b95a7916ffa17baf
Data : 新建一个区块，名字为No.4
IsValid : true
解码传入的数据: 7aff8103010105426c6f636b01ff82000108010756657273696f6e010600010d50726576426c6f636b48617368010a00010a4d65724b6c65526f6f74010a00010954696d655374616d70010600010b446966666963756c69747901060001054e6f6e6365010600010444617461010a00010448617368010a00000078ff82022000000621e6b5bfca5729310daaae10c41815e9ee37454d505afac7fc61e912b302fc6125e5a1011401fd21960a0122e696b0e5bbbae4b880e4b8aae58cbae59d97efbc8ce5908de5ad97e4b8ba4e6f2e33012000000e24eb745ebed78303da175b7fd12a91326ddb97d5d38ca1111652380e4100
--------------
Version : 0
PrevBlockHash : 00000621e6b5bfca5729310daaae10c41815e9ee37454d505afac7fc61e912b3
MerKleRoot : 
TimeStamp : 2021-08-25 14:39:29
Difficulity : 20
Nonce : 2201098
Hash : 00000e24eb745ebed78303da175b7fd12a91326ddb97d5d38ca1111652380e41
Data : 新建一个区块，名字为No.3
IsValid : true
解码传入的数据: 7aff8103010105426c6f636b01ff82000108010756657273696f6e010600010d50726576426c6f636b48617368010a00010a4d65724b6c65526f6f74010a00010954696d655374616d70010600010b446966666963756c69747901060001054e6f6e6365010600010444617461010a00010448617368010a00000078ff82022000000d49e238001fd0878cc5766939c444b583d04bf36cb6110020bb3b95c8da02fc6125e57d011401fd01117c0122e696b0e5bbbae4b880e4b8aae58cbae59d97efbc8ce5908de5ad97e4b8ba4e6f2e32012000000621e6b5bfca5729310daaae10c41815e9ee37454d505afac7fc61e912b300
--------------
Version : 0
PrevBlockHash : 00000d49e238001fd0878cc5766939c444b583d04bf36cb6110020bb3b95c8da
MerKleRoot : 
TimeStamp : 2021-08-25 14:38:53
Difficulity : 20
Nonce : 70012
Hash : 00000621e6b5bfca5729310daaae10c41815e9ee37454d505afac7fc61e912b3
Data : 新建一个区块，名字为No.2
IsValid : true
解码传入的数据: 7aff8103010105426c6f636b01ff82000108010756657273696f6e010600010d50726576426c6f636b48617368010a00010a4d65724b6c65526f6f74010a00010954696d655374616d70010600010b446966666963756c69747901060001054e6f6e6365010600010444617461010a00010448617368010a00000078ff820220000006008a2715059823c5c13d58a1fafd92a2767ca1973a36aed7ed238c8ab502fc6125e57c011401fd04f6a80122e696b0e5bbbae4b880e4b8aae58cbae59d97efbc8ce5908de5ad97e4b8ba4e6f2e31012000000d49e238001fd0878cc5766939c444b583d04bf36cb6110020bb3b95c8da00
--------------
Version : 0
PrevBlockHash : 000006008a2715059823c5c13d58a1fafd92a2767ca1973a36aed7ed238c8ab5
MerKleRoot : 
TimeStamp : 2021-08-25 14:38:52
Difficulity : 20
Nonce : 325288
Hash : 00000d49e238001fd0878cc5766939c444b583d04bf36cb6110020bb3b95c8da
Data : 新建一个区块，名字为No.1
IsValid : true
解码传入的数据: 7aff8103010105426c6f636b01ff82000108010756657273696f6e010600010d50726576426c6f636b48617368010a00010a4d65724b6c65526f6f74010a00010954696d655374616d70010600010b446966666963756c69747901060001054e6f6e6365010600010444617461010a00010448617368010a00000078ff82022000000ce3112aaada48c72c346f632ebdb17cc32610361423ae7629a796b6ec6902fc6125e190011401fd1aa0d70122e696b0e5bbbae4b880e4b8aae58cbae59d97efbc8ce5908de5ad97e4b8ba4e6f2e320120000006008a2715059823c5c13d58a1fafd92a2767ca1973a36aed7ed238c8ab500
--------------
Version : 0
PrevBlockHash : 00000ce3112aaada48c72c346f632ebdb17cc32610361423ae7629a796b6ec69
MerKleRoot : 
TimeStamp : 2021-08-25 14:22:08
Difficulity : 20
Nonce : 1745111
Hash : 000006008a2715059823c5c13d58a1fafd92a2767ca1973a36aed7ed238c8ab5
Data : 新建一个区块，名字为No.2
IsValid : true
解码传入的数据: 7aff8103010105426c6f636b01ff82000108010756657273696f6e010600010d50726576426c6f636b48617368010a00010a4d65724b6c65526f6f74010a00010954696d655374616d70010600010b446966666963756c69747901060001054e6f6e6365010600010444617461010a00010448617368010a00000078ff82022000000fbcf2078162273ce499be75cb150d191a4f7a1f04db7932fc48fd46baac02fc6125e190011401fd04685a0122e696b0e5bbbae4b880e4b8aae58cbae59d97efbc8ce5908de5ad97e4b8ba4e6f2e31012000000ce3112aaada48c72c346f632ebdb17cc32610361423ae7629a796b6ec6900
--------------
Version : 0
PrevBlockHash : 00000fbcf2078162273ce499be75cb150d191a4f7a1f04db7932fc48fd46baac
MerKleRoot : 
TimeStamp : 2021-08-25 14:22:08
Difficulity : 20
Nonce : 288858
Hash : 00000ce3112aaada48c72c346f632ebdb17cc32610361423ae7629a796b6ec69
Data : 新建一个区块，名字为No.1
IsValid : true
解码传入的数据: 7aff8103010105426c6f636b01ff82000108010756657273696f6e010600010d50726576426c6f636b48617368010a00010a4d65724b6c65526f6f74010a00010954696d655374616d70010600010b446966666963756c69747901060001054e6f6e6365010600010444617461010a00010448617368010a00000079ff8204fc6125e18f011401fd0e788a01455468652054696d65732030332f4a616e2f32303039204368616e63656c6c6f72206f6e206272696e6b206f66207365636f6e64206261696c6f757420666f722062616e6b73012000000fbcf2078162273ce499be75cb150d191a4f7a1f04db7932fc48fd46baac00
--------------
Version : 0
PrevBlockHash : 
MerKleRoot : 
TimeStamp : 2021-08-25 14:22:07
Difficulity : 20
Nonce : 948362
Hash : 00000fbcf2078162273ce499be75cb150d191a4f7a1f04db7932fc48fd46baac
Data : The Times 03/Jan/2009 Chancellor on brink of second bailout for banks
IsValid : true
区块链遍历结束!

Process finished with exit code 0
```

目前使用数据库进行改写已经完成。

## 命令行操作

使用一个简单的Demo：

```go
package main

import (
	"os"
	"fmt"
)

func main() {
	cmds := os.Args  //返回的是一个命令行字符串 数组

	for i, cmd := range cmds { //遍历打印
		fmt.Printf("cmd[%d] : %s\n", i, cmd)
	}
}
```

输出：

```
go run osArgsDemo.go add
cmd[0] : C:\Users\13375\AppData\Local\Temp\go-build2987797689\b001\exe\osArgsDemo.exe
cmd[1] : add

```

## 使用命令行分析

所有的操作都由命令行来操作，主函数只需要调用命令就可以。

CLI ： command line 的缩写

```go
type CLI struct {
      bc *BlockChain
}
```

添加区块的时候： bc.addBlock(data), data 通过os.Args拿回来

打印区块链时候：遍历区块链，不需要外部输入数据

cli.go 实现：

```go
package main

import (
	"fmt"
	"os"
)

const Usage = `
	./blockchain addBlock "xxxx"   添加数据到区块链
	./blockchain printChain          打印区块链
`

type CLI struct {
	bc *BlockChain
}

//命令解析，方法调用
func (cli *CLI) Run() {

	cmds := os.Args //获取命令数组

	if len(cmds) < 2 {
		fmt.Printf(Usage)
		os.Exit(1)
	}

	switch cmds[1] {
	case "addBlock":
		fmt.Printf("添加区块命令调用, 数据：%s\n", cmds[2]) //添加区块的时候： bc.addBlock(data), data 通过os.Args拿回来
	case "printChain":
		fmt.Printf("打印区块链命令调用\n")	//打印区块链时候：遍历区块链，不需要外部输入数据
	default:
		fmt.Printf("无效的命令，请检查\n")
		fmt.Printf(Usage)
	}
	

}
```

## 改写main函数

```go
package main

import (
	"fmt"
)

func main() {

	bc := NewBlockChain()
	fmt.Println("创建一个区块链")

	defer bc.db.Close()

	cli := CLI{bc}
	cli.Run()
}
```

## 添加commands.go

用这个文件来实现具体的命令方法：（就是把之前main函数中的方法单独拿出来）

```go
package main

import (
	"bytes"
	"fmt"
	"time"
)

func (cli *CLI) AddBlock(data string) {
	cli.bc.AddBlock(data)
	fmt.Printf("添加区块成功!\n")
}

func (cli *CLI) PrintChain() {

	it := cli.bc.NewIterator()
	
	for {
		block := it.Next()
	
		fmt.Printf("--------------\n")
		fmt.Printf("Version : %d\n", block.Version)
		fmt.Printf("PrevBlockHash : %x\n", block.PrevBlockHash)
		fmt.Printf("MerKleRoot : %x\n", block.MerKleRoot)
	
		timeFormat := time.Unix(int64(block.TimeStamp), 0).Format("2006-01-02 15:04:05")
		fmt.Printf("TimeStamp : %s\n", timeFormat)
		fmt.Printf("Difficulity : %d\n", block.Difficulity)
		fmt.Printf("Nonce : %d\n", block.Nonce)
		fmt.Printf("Hash : %x\n", block.Hash)
		fmt.Printf("Data : %s\n", block.Data)
	
		pow := NewProofOfWork(block)
		fmt.Printf("IsValid : %v\n", pow.IsValid())
	
		if bytes.Equal(block.PrevBlockHash, []byte{}) {
			fmt.Printf("区块链遍历结束!\n")
			break
		}
	}
}
```

测试：

```
go run . printChain
```

```
go run . printChain
创建一个区块链
打印区块链命令调用
解码传入的数据: 7aff8103010105426c6f636b01ff82000108010756657273696f6e010600010d50726576426c6f636b48617368010a00010a4d65724b6c65526f6f74010a00010954696d655374616d70010600010b44696666696
3756c69747901060001054e6f6e6365010600010444617461010a00010448617368010a00000078ff82022000000e24eb745ebed78303da175b7fd12a91326ddb97d5d38ca1111652380e4102fc6125e5a3011401fd01d2460122e696
b0e5bbbae4b880e4b8aae58cbae59d97efbc8ce5908de5ad97e4b8ba4e6f2e3401200000085aec3c1bf8606c04abfad78b9853774fb6ccf09644b95a7916ffa17baf00
--------------
Version : 0
PrevBlockHash : 00000e24eb745ebed78303da175b7fd12a91326ddb97d5d38ca1111652380e41
MerKleRoot :
TimeStamp : 2021-08-25 14:39:31
Difficulity : 20
Nonce : 119366
Hash : 0000085aec3c1bf8606c04abfad78b9853774fb6ccf09644b95a7916ffa17baf
Data : 新建一个区块，名字为No.4
IsValid : true
解码传入的数据: 7aff8103010105426c6f636b01ff82000108010756657273696f6e010600010d50726576426c6f636b48617368010a00010a4d65724b6c65526f6f74010a00010954696d655374616d70010600010b44696666696
3756c69747901060001054e6f6e6365010600010444617461010a00010448617368010a00000078ff82022000000621e6b5bfca5729310daaae10c41815e9ee37454d505afac7fc61e912b302fc6125e5a1011401fd21960a0122e696
b0e5bbbae4b880e4b8aae58cbae59d97efbc8ce5908de5ad97e4b8ba4e6f2e33012000000e24eb745ebed78303da175b7fd12a91326ddb97d5d38ca1111652380e4100
--------------
Version : 0
PrevBlockHash : 00000621e6b5bfca5729310daaae10c41815e9ee37454d505afac7fc61e912b3
MerKleRoot :
TimeStamp : 2021-08-25 14:39:29
Difficulity : 20
Nonce : 2201098
Hash : 00000e24eb745ebed78303da175b7fd12a91326ddb97d5d38ca1111652380e41
Data : 新建一个区块，名字为No.3
IsValid : true
解码传入的数据: 7aff8103010105426c6f636b01ff82000108010756657273696f6e010600010d50726576426c6f636b48617368010a00010a4d65724b6c65526f6f74010a00010954696d655374616d70010600010b44696666696
3756c69747901060001054e6f6e6365010600010444617461010a00010448617368010a00000078ff82022000000d49e238001fd0878cc5766939c444b583d04bf36cb6110020bb3b95c8da02fc6125e57d011401fd01117c0122e696
b0e5bbbae4b880e4b8aae58cbae59d97efbc8ce5908de5ad97e4b8ba4e6f2e32012000000621e6b5bfca5729310daaae10c41815e9ee37454d505afac7fc61e912b300
--------------
Version : 0
PrevBlockHash : 00000d49e238001fd0878cc5766939c444b583d04bf36cb6110020bb3b95c8da
MerKleRoot :
TimeStamp : 2021-08-25 14:38:53
Difficulity : 20
Nonce : 70012
Hash : 00000621e6b5bfca5729310daaae10c41815e9ee37454d505afac7fc61e912b3
Data : 新建一个区块，名字为No.2
IsValid : true
解码传入的数据: 7aff8103010105426c6f636b01ff82000108010756657273696f6e010600010d50726576426c6f636b48617368010a00010a4d65724b6c65526f6f74010a00010954696d655374616d70010600010b44696666696
3756c69747901060001054e6f6e6365010600010444617461010a00010448617368010a00000078ff820220000006008a2715059823c5c13d58a1fafd92a2767ca1973a36aed7ed238c8ab502fc6125e57c011401fd04f6a80122e696
b0e5bbbae4b880e4b8aae58cbae59d97efbc8ce5908de5ad97e4b8ba4e6f2e31012000000d49e238001fd0878cc5766939c444b583d04bf36cb6110020bb3b95c8da00
--------------
Version : 0
PrevBlockHash : 000006008a2715059823c5c13d58a1fafd92a2767ca1973a36aed7ed238c8ab5
MerKleRoot :
TimeStamp : 2021-08-25 14:38:52
Difficulity : 20
Nonce : 325288
Hash : 00000d49e238001fd0878cc5766939c444b583d04bf36cb6110020bb3b95c8da
Data : 新建一个区块，名字为No.1
IsValid : true
解码传入的数据: 7aff8103010105426c6f636b01ff82000108010756657273696f6e010600010d50726576426c6f636b48617368010a00010a4d65724b6c65526f6f74010a00010954696d655374616d70010600010b44696666696
3756c69747901060001054e6f6e6365010600010444617461010a00010448617368010a00000078ff82022000000ce3112aaada48c72c346f632ebdb17cc32610361423ae7629a796b6ec6902fc6125e190011401fd1aa0d70122e696
b0e5bbbae4b880e4b8aae58cbae59d97efbc8ce5908de5ad97e4b8ba4e6f2e320120000006008a2715059823c5c13d58a1fafd92a2767ca1973a36aed7ed238c8ab500
--------------
Version : 0
PrevBlockHash : 00000ce3112aaada48c72c346f632ebdb17cc32610361423ae7629a796b6ec69
MerKleRoot :
TimeStamp : 2021-08-25 14:22:08
Difficulity : 20
Nonce : 1745111
Hash : 000006008a2715059823c5c13d58a1fafd92a2767ca1973a36aed7ed238c8ab5
Data : 新建一个区块，名字为No.2
IsValid : true
解码传入的数据: 7aff8103010105426c6f636b01ff82000108010756657273696f6e010600010d50726576426c6f636b48617368010a00010a4d65724b6c65526f6f74010a00010954696d655374616d70010600010b44696666696
3756c69747901060001054e6f6e6365010600010444617461010a00010448617368010a00000078ff82022000000fbcf2078162273ce499be75cb150d191a4f7a1f04db7932fc48fd46baac02fc6125e190011401fd04685a0122e696
b0e5bbbae4b880e4b8aae58cbae59d97efbc8ce5908de5ad97e4b8ba4e6f2e31012000000ce3112aaada48c72c346f632ebdb17cc32610361423ae7629a796b6ec6900
--------------
Version : 0
PrevBlockHash : 00000fbcf2078162273ce499be75cb150d191a4f7a1f04db7932fc48fd46baac
MerKleRoot :
TimeStamp : 2021-08-25 14:22:08
Difficulity : 20
Nonce : 288858
Hash : 00000ce3112aaada48c72c346f632ebdb17cc32610361423ae7629a796b6ec69
Data : 新建一个区块，名字为No.1
IsValid : true
解码传入的数据: 7aff8103010105426c6f636b01ff82000108010756657273696f6e010600010d50726576426c6f636b48617368010a00010a4d65724b6c65526f6f74010a00010954696d655374616d70010600010b44696666696
3756c69747901060001054e6f6e6365010600010444617461010a00010448617368010a00000079ff8204fc6125e18f011401fd0e788a01455468652054696d65732030332f4a616e2f32303039204368616e63656c6c6f72206f6e20
6272696e6b206f66207365636f6e64206261696c6f757420666f722062616e6b73012000000fbcf2078162273ce499be75cb150d191a4f7a1f04db7932fc48fd46baac00
--------------
Version : 0
PrevBlockHash :
MerKleRoot :
TimeStamp : 2021-08-25 14:22:07
Difficulity : 20
Nonce : 948362
Hash : 00000fbcf2078162273ce499be75cb150d191a4f7a1f04db7932fc48fd46baac
Data : The Times 03/Jan/2009 Chancellor on brink of second bailout for banks
IsValid : true
区块链遍历结束!

```

