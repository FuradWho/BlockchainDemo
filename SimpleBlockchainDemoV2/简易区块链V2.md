# 简易区块链V2

## 设计思路

### POW介绍

定义一个工作量证明的结构ProofOfWork

a. block

b. 目标值

![image-20210824140618446](C:\Users\13375\AppData\Roaming\Typora\typora-user-images\image-20210824140618446.png)

### 提供创建POW的函数

NewProofOfWork(参数)

### 提供计算不断计算hash的哈数

Run()

### 提供一个校验函数

IsValid()

## Pow的定义

我们使用 big.Int 进行哈希的一个比较，设计代码：

proofofwork.go:

```go
package main

import "math/big"

/*

定义一个工作量证明的结构ProofOfWork
	a. block
	b. 目标值
提供创建POW的函数
	NewProofOfWork(参数)
提供计算不断计算hash的哈数
	Run()
提供一个校验函数
	IsValid()
*/

type ProofOfWork struct {

	block *Block

	//来存储哈希值，它内置一些方法Cmp:比较方法
	// SetBytes : 把bytes转成big.int类型 []byte("0x00000919011eeb8fbdf0c476d8510b8e1e632eba7b584ac04c11ad20cbbdd394")
	// SetString : 把string转成big.int类型 "0x00000919011eeb8fbdf0c476d8510b8e1e632eba7b584ac04c11ad20cbbdd394"
	target *big.Int  //系统提供的，是固定的
}

func NewProofOfWork(block *Block) *ProofOfWork {

	pow := ProofOfWork{
		block: block,
	}

	//写难度值，难度值应该是推导出来的，但是我们为了简化，把难度值先写成固定的，一切完成之后，再去推导
	// 0000100000000000000000000000000000000000000000000000000000000000

	targetStr := "0000100000000000000000000000000000000000000000000000000000000000"  	//16制格式的字符串
	var bigIntTmp big.Int
	bigIntTmp.SetString(targetStr, 16)
	pow.target = &bigIntTmp

	return &pow

}
```

## Run函数实现

run函数的主要功能就是实现获取挖矿的随机数，同时返回区块的哈希值。

大致结构：

1. 获取区块数据
2. 将区块数据与变化的nonce进行拼接
3. 计算拼接后数据的哈希值
4. 将结果与难度值进行比较，使用big.Int 的CMP函数
5. 若得到结果，对于结果进行返回

proofofwork.go文件下具体实现:

```go
package main

import (
	"bytes"
	"crypto/sha256"
	"fmt"
	"math/big"
)

/*

定义一个工作量证明的结构ProofOfWork
	a. block
	b. 目标值
提供创建POW的函数
	NewProofOfWork(参数)
提供计算不断计算hash的哈数
	Run()
提供一个校验函数
	IsValid()
*/

type ProofOfWork struct {

	block *Block

	//来存储哈希值，它内置一些方法Cmp:比较方法
	// SetBytes : 把bytes转成big.int类型 []byte("0x00000919011eeb8fbdf0c476d8510b8e1e632eba7b584ac04c11ad20cbbdd394")
	// SetString : 把string转成big.int类型 "0x00000919011eeb8fbdf0c476d8510b8e1e632eba7b584ac04c11ad20cbbdd394"
	target *big.Int  //系统提供的，是固定的
}

func NewProofOfWork(block *Block) *ProofOfWork {

	pow := ProofOfWork{
		block: block,
	}

	//写难度值，难度值应该是推导出来的，但是我们为了简化，把难度值先写成固定的，一切完成之后，再去推导
	// 0000100000000000000000000000000000000000000000000000000000000000

	targetStr := "0000100000000000000000000000000000000000000000000000000000000000"  	//16制格式的字符串
	var bigIntTmp big.Int
	bigIntTmp.SetString(targetStr, 16)
	pow.target = &bigIntTmp

	return &pow

}

//这是pow的运算函数，为了获取挖矿的随机数，同时返回区块的哈希值
func (pow *ProofOfWork) Run() ([]byte ,uint64)  {

	//1. 获取block数据
	//2. 拼接nonce
	//3. sha256
	//4. 与难度值比较
	//		a. 哈希值大于难度值，nonce++
	//		b. 哈希值小于难度值，挖矿成功,退出

	//定义一个nonce
	var nonce uint64
	//定义返回值的Hash值
	var hash [32]byte

	for ; ; {

		//data := block + nonce
		hash = sha256.Sum256(pow.prepareData(nonce))

		//将hash（数组类型）转成big.int, 然后与pow.target进行比较, 需要引入局部变量
		var bigIntTmp big.Int
		bigIntTmp.SetBytes(hash[:])

		//   -1 if x <  y
		//    0 if x == y
		//   +1 if x >  y
		if bigIntTmp.Cmp(pow.target) == -1 {
			// x < y ， 挖矿成功！
			fmt.Printf("挖矿成功！nonce: %d, 哈希值为: %x\n", nonce, hash)
			break
		} else {
			nonce ++
		}
	}
	return hash[:], nonce

}

//定义一个prepareData函数，用来进行 区块数据 和 nonce 的拼接
func (pow *ProofOfWork) prepareData(nonce uint64) []byte {
	block := pow.block

	tmp := [][]byte{
		uintToByte(block.Version),
		block.PrevBlockHash,
		block.MerKleRoot,
		uintToByte(block.TimeStamp),
		uintToByte(block.Difficulity),
		block.Data,
		uintToByte(nonce),
	}

	data := bytes.Join(tmp, []byte{})
	return data
}
```

## 使用Pow更新NewBlock

我们之前对于区块哈希值的计算是一个固定的SetHash函数，但是我们已经实现了Pow函数，返回值是区块的hash以及nonce值。所以我们对于区块进行一个更新。

block.go文件下：

```go
package main

import (
	"time"
)

/*
大致流程：

	1. 定义结构（区块头的字段比正常的少）
		1. 前区块哈希
		2. 当前区块哈希
		3. 数据
	2. 创建区块
	3. 生成哈希
	4. 引入区块链
	5. 添加区块
	6. 重构代码

*/

const genesisInfo = "The Times 03/Jan/2009 Chancellor on brink of second bailout for banks"

// 1.定义结构（区块头的字段比正常的少）
type Block struct {
	Version       uint64 //区块版本号
	PrevBlockHash []byte //前区块哈希
	MerKleRoot    []byte //先填写为空，后续使用
	TimeStamp     uint64 //从1970.1.1至今的秒数
	Difficulity   uint64 //挖矿的难度值, v2时使用
	Nonce         uint64 //随机数，挖矿找的就是它!
	Data          []byte //数据，目前使用字节流，v4开始使用交易代替
	Hash          []byte //当前区块哈希, 区块中本不存在的字段，为了方便我们添加进来
}

// 2. 创建区块
func NewBlock(data string, prevBlockHash []byte) *Block {

	block := Block{
		Version:       00,
		PrevBlockHash: prevBlockHash,
		MerKleRoot:    []byte{},
		TimeStamp:     uint64(time.Now().Unix()),
		Difficulity:   10, //随便写的，后续调整
		Nonce:         10, //同Difficulty
		Data:          []byte(data),
		Hash:          []byte{}, //先填充为空，后续会填充数据
	}

	// block.SetHash() 生成Hash值

	pow := NewProofOfWork(&block)
	hash , nonce := pow.Run()
	
	block.Hash = hash
	block.Nonce = nonce

	return &block
}

/*
// 我们实现一个简单的函数，去进行哈希值的计算，没有随机值，没有难度值
func (block *Block) SetHash() {
	var data []byte

	//uintToByte将数字转成[]byte{}, 在utils.go实现
	//data = append(data, uintToByte(block.Version)...)
	//data = append(data, block.PrevBlockHash...)
	//data = append(data, block.MerKleRoot...)
	//data = append(data, uintToByte(block.TimeStamp)...)
	//data = append(data, uintToByte(block.Difficulity)...)
	//data = append(data, block.Data...)
	//data = append(data, uintToByte(block.Nonce)...)

	tmp := [][]byte{
		uintToByte(block.Version),
		block.PrevBlockHash,
		block.MerKleRoot,
		uintToByte(block.TimeStamp),
		uintToByte(block.Difficulity),
		block.Data,
		uintToByte(block.Nonce),
	}

	data = bytes.Join(tmp, []byte{})

	hash := sha256.Sum256(data)
	block.Hash = hash[:]
}

 */
```

运行main.go 我们进行整个区块链。

打印输出：

```
挖矿成功！nonce: 934861, 哈希值为: 00000fa71bd488e38552ae21af97db5ffde687d132de0113a1a4688a6af6bf97
创建一个区块链
挖矿成功！nonce: 396975, 哈希值为: 0000062e957dd732d6f1349c0405c615668cef6517eb4fb7136c4dc2acd98f11
--------------
区块高度: 0
PrevBlockHash : 00
Hash : 00000fa71bd488e38552ae21af97db5ffde687d132de0113a1a4688a6af6bf97
Data : The Times 03/Jan/2009 Chancellor on brink of second bailout for banks
--------------
区块高度: 1
PrevBlockHash : 00000fa71bd488e38552ae21af97db5ffde687d132de0113a1a4688a6af6bf97
Hash : 0000062e957dd732d6f1349c0405c615668cef6517eb4fb7136c4dc2acd98f11
Data : 新建一个区块，名字为first

Process finished with exit code 0

```

## 校验挖矿是否有效

我们需要进行对于挖矿结果的一个校验，所以我们添加一个IsValid函数，用来验证。

proofofwork.go文件下具体实现：

```go
//校验 ，block的数据是完整的，我们要做的是校验一下，Hash，block数据，和Nonce是否满足难度值要求
func (pow *ProofOfWork) IsValid() bool {
	//获取block数据
	//拼接nonce
	//做sha256
	//比较

	data := pow.prepareData(pow.block.Nonce)
	hash := sha256.Sum256(data)

	var tmp big.Int
	tmp.SetBytes(hash[:])

	return tmp.Cmp(pow.target) == -1
}
```

打印输出：

```
挖矿成功！nonce: 2017824, 哈希值为: 0000065b3b264275dec203cb52a5cde2ef33fc624c8b2e5dc5c1a9263da245e5
创建一个区块链
挖矿成功！nonce: 117542, 哈希值为: 00000b0d2d050fd6a0abb78a07d8fdfccb685cb7c0074ef8a2daccc4fdbfaa23
挖矿成功！nonce: 2143042, 哈希值为: 000004b1f230e316312fcd8e4c3d32246ca5037a91f2e0e8faca4d4109bbb5cc
--------------
区块高度: 0
PrevBlockHash : 00
Hash : 0000065b3b264275dec203cb52a5cde2ef33fc624c8b2e5dc5c1a9263da245e5
Data : The Times 03/Jan/2009 Chancellor on brink of second bailout for banks
IsValid : true
--------------
区块高度: 1
PrevBlockHash : 0000065b3b264275dec203cb52a5cde2ef33fc624c8b2e5dc5c1a9263da245e5
Hash : 00000b0d2d050fd6a0abb78a07d8fdfccb685cb7c0074ef8a2daccc4fdbfaa23
Data : 新建一个区块，名字为No.1
IsValid : true
--------------
区块高度: 2
PrevBlockHash : 00000b0d2d050fd6a0abb78a07d8fdfccb685cb7c0074ef8a2daccc4fdbfaa23
Hash : 000004b1f230e316312fcd8e4c3d32246ca5037a91f2e0e8faca4d4109bbb5cc
Data : 新建一个区块，名字为No.2
IsValid : true

Process finished with exit code 0

```

## 补充打印Block字段

main.go文件之下，进行修改：

```go
func main() {

	bc := NewBlockChain()
	fmt.Println("创建一个区块链")

	bc.AddBlock("新建一个区块，名字为No.1")
	bc.AddBlock("新建一个区块，名字为No.2")

	for i, block := range bc.Blocks {

		fmt.Printf("--------------\n")
		fmt.Printf("区块高度: %d\n", i)
		fmt.Printf("Version : %d\n", block.Version)
		fmt.Printf("PrevBlockHash : %x\n", block.PrevBlockHash)
		fmt.Printf("MerKleRoot : %x\n", block.MerKleRoot)

		timeFormat := time.Unix(int64(block.TimeStamp), 0).Format("2006-01-02 15:04:05")
		fmt.Printf("TimeStamp : %s\n", timeFormat)

		fmt.Printf("Difficulity : %d\n", block.Difficulity)
		fmt.Printf("Nonce : %d\n", block.Nonce)
		fmt.Printf("Hash : %x\n", block.Hash)
		fmt.Printf("Data : %s\n", block.Data)

		pow := NewProofOfWork(block)
		fmt.Printf("IsValid : %v\n", pow.IsValid())


	}

}

```

打印输出：

```
挖矿成功！nonce: 40178, 哈希值为: 00000ab0baa001eedb6319893eb4e0c0e6b226b7ca3811c6bc9fb8ce285945c9
创建一个区块链
挖矿成功！nonce: 2205587, 哈希值为: 0000072a9a246d87006554073cc0512f7dfc6e97fda8899321085b8c7b347837
挖矿成功！nonce: 335442, 哈希值为: 000004e59c7376f8f2aaa7a0ee28b18cabe9aca0d0950a210a68d25354684233
--------------
区块高度: 0
Version : 0
PrevBlockHash : 00
MerKleRoot : 
TimeStamp : 2021-08-24 14:32:59
Difficulity : 10
Nonce : 40178
Hash : 00000ab0baa001eedb6319893eb4e0c0e6b226b7ca3811c6bc9fb8ce285945c9
Data : The Times 03/Jan/2009 Chancellor on brink of second bailout for banks
IsValid : true
--------------
区块高度: 1
Version : 0
PrevBlockHash : 00000ab0baa001eedb6319893eb4e0c0e6b226b7ca3811c6bc9fb8ce285945c9
MerKleRoot : 
TimeStamp : 2021-08-24 14:32:59
Difficulity : 10
Nonce : 2205587
Hash : 0000072a9a246d87006554073cc0512f7dfc6e97fda8899321085b8c7b347837
Data : 新建一个区块，名字为No.1
IsValid : true
--------------
区块高度: 2
Version : 0
PrevBlockHash : 0000072a9a246d87006554073cc0512f7dfc6e97fda8899321085b8c7b347837
MerKleRoot : 
TimeStamp : 2021-08-24 14:33:02
Difficulity : 10
Nonce : 335442
Hash : 000004e59c7376f8f2aaa7a0ee28b18cabe9aca0d0950a210a68d25354684233
Data : 新建一个区块，名字为No.2
IsValid : true

Process finished with exit code 0
```

## 使用Bits推导难度值

因为我们之前所写的难度值是一个固定的值，但是我们想动态的进行改变，所以进行难度值的一个推导。

proofofwork.go文件之下的NewProofOfWork函数进行修改：

```go
const Bits = 20

func NewProofOfWork(block *Block) *ProofOfWork {

	pow := ProofOfWork{
		block: block,
	}

	//先去初始化  0000000000000000000000000000000000000000000000000000000000000001
	bigIntTmp := big.NewInt(1)
	//左移256 - Bits 动态调整1的位置
	bigIntTmp.Lsh(bigIntTmp, 256 - Bits)
	pow.target = bigIntTmp

	return &pow

}

```

打印输出：

```
挖矿成功！nonce: 76449, 哈希值为: 00000b6c0c07807f3c261c2b11336c0e573fe5bb6f7dfb06fc5dfd5ddd191276
创建一个区块链
挖矿成功！nonce: 1804939, 哈希值为: 0000004239e2751c1baa6cfb78817c9dc70feb3d1d54f465584bbed15a1e0cc9
挖矿成功！nonce: 2543970, 哈希值为: 0000064dcad38e1b408db46b9dfe0ad084c1f84dd2eb556819efa89e1be44de3
--------------
区块高度: 0
Version : 0
PrevBlockHash : 00
MerKleRoot : 
TimeStamp : 2021-08-24 14:42:51
Difficulity : 20
Nonce : 76449
Hash : 00000b6c0c07807f3c261c2b11336c0e573fe5bb6f7dfb06fc5dfd5ddd191276
Data : The Times 03/Jan/2009 Chancellor on brink of second bailout for banks
IsValid : true
--------------
区块高度: 1
Version : 0
PrevBlockHash : 00000b6c0c07807f3c261c2b11336c0e573fe5bb6f7dfb06fc5dfd5ddd191276
MerKleRoot : 
TimeStamp : 2021-08-24 14:42:52
Difficulity : 20
Nonce : 1804939
Hash : 0000004239e2751c1baa6cfb78817c9dc70feb3d1d54f465584bbed15a1e0cc9
Data : 新建一个区块，名字为No.1
IsValid : true
--------------
区块高度: 2
Version : 0
PrevBlockHash : 0000004239e2751c1baa6cfb78817c9dc70feb3d1d54f465584bbed15a1e0cc9
MerKleRoot : 
TimeStamp : 2021-08-24 14:42:53
Difficulity : 20
Nonce : 2543970
Hash : 0000064dcad38e1b408db46b9dfe0ad084c1f84dd2eb556819efa89e1be44de3
Data : 新建一个区块，名字为No.2
IsValid : true

Process finished with exit code 0
```





















